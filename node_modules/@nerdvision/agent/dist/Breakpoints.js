"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inspector_1 = __importDefault(require("inspector"));
const Logger_1 = __importDefault(require("./utils/Logger"));
const Debug_1 = require("./apis/Debug");
const Injectable_1 = __importDefault(require("./decorators/Injectable"));
const Timer_1 = __importDefault(require("./utils/Timer"));
const Events_1 = __importDefault(require("./apis/Events"));
const RuntimeProps_1 = __importDefault(require("./apis/RuntimeProps"));
const Configuration_1 = __importDefault(require("./models/Configuration"));
const Snapshot_1 = __importDefault(require("./models/Snapshot"));
const Mappings_1 = __importDefault(require("./utils/Mappings"));
const source_map_1 = require("source-map");
const Container_1 = __importDefault(require("./utils/Container"));
let Breakpoints = class Breakpoints {
    constructor(_debug, _events, _mappings, session) {
        this._debug = _debug;
        this._events = _events;
        this._mappings = _mappings;
        this.session = session;
        this._list = [];
        this._pending = [];
        this._mappings.mappingParsed = this.mappingParsed.bind(this);
    }
    /**
     * Update the set breakpoints with the new list of breakpoints
     *
     * @param newBreakpoints The list of breakpoints that should be set
     */
    mergeList(newBreakpoints) {
        return __awaiter(this, void 0, void 0, function* () {
            // remove existing breakpoints that are no longer set
            this._list = this._list.filter(bp => {
                const remove = !newBreakpoints.some(nbp => bp.breakpoint.getBreakpointId() === nbp.getBreakpointId());
                if (remove) {
                    this._debug.removeBreakpoint(bp.breakpointId);
                    Logger_1.default.breakpoint('breakpoint removed ', bp.breakpoint);
                }
                return !remove;
            });
            // remove pending breakpoints that are no longer set
            this._pending = this._pending.filter(breakpoint => {
                return newBreakpoints.some(bp => bp.getBreakpointId() === breakpoint.getBreakpointId());
            });
            // add new breakpoints
            yield Promise.all(newBreakpoints.map((breakpoint) => __awaiter(this, void 0, void 0, function* () {
                const isActive = this._list.some(obp => breakpoint.getBreakpointId() === obp.breakpoint.getBreakpointId());
                const isPending = this._pending.some(obp => breakpoint.getBreakpointId() === obp.getBreakpointId());
                if (!isActive && !isPending) {
                    yield this.addBreakpoint(breakpoint);
                }
            })));
            Logger_1.default.info('breakpoints active:', this._list.length);
            if (this._pending.length) {
                Logger_1.default.info('breakpoints pending:', this._pending.length);
            }
        });
    }
    /**
     * Find the requested breakpoint
     *
     * @param breakpointId The id of the breakpoint
     */
    find(breakpointId) {
        return this._list.find(bp => bp.breakpointId === breakpointId);
    }
    /**
     * Add the given breakpoint
     *
     * @param breakpoint The breakpoint to add
     */
    addBreakpoint(breakpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = Configuration_1.default.root + breakpoint.getRelPath();
            const rawBPPath = url.substring(7);
            let lineNumber = breakpoint.getLineNo();
            let columnNumber = 0;
            // if the file hasn't been loaded yet, or doesn't have any mappings
            // TODO: don't think this logic is right
            if (!this._mappings.seen(rawBPPath) && !this._mappings.has(rawBPPath)) {
                // add the breakpoint to the pending list to keep track of it
                if (!this._pending.some(bp => bp.getBreakpointId() === breakpoint.getBreakpointId())) {
                    this._pending.push(breakpoint);
                    Logger_1.default.breakpoint('breakpoint pending source file loading', breakpoint);
                }
                return;
            }
            // remove the breakpoint from the pending list as we're adding it now
            this._pending = this._pending.filter(bp => bp.getBreakpointId() !== breakpoint.getBreakpointId());
            // if the file has a source map, we'll get the original source location, line number and column number
            if (this._mappings.has(rawBPPath)) {
                const map = this._mappings.get(rawBPPath);
                map.sourceRoot = Configuration_1.default.rootPath + '/';
                map.file = map.originalFilePath.substr(Configuration_1.default.root.length);
                map.sources = [breakpoint.getRelPath()];
                url = Configuration_1.default.root + map.file;
                yield source_map_1.SourceMapConsumer.with(map, null, (consumer) => __awaiter(this, void 0, void 0, function* () {
                    const originalPosition = {
                        line: lineNumber,
                        source: rawBPPath,
                        column: 0
                    };
                    ({ line: lineNumber, column: columnNumber } = consumer.generatedPositionFor(originalPosition));
                }));
            }
            // both nerd.vision and the source map package have line numbers starting at 1, whereas the debugger starts at 0
            lineNumber -= 1;
            const breakpointId = this._debug.addBreakpoint(breakpoint, {
                url,
                lineNumber,
                columnNumber
            }, this.breakpointFired.bind(this));
            this._list.push({ breakpoint, breakpointId, column: columnNumber });
            Logger_1.default.breakpoint('breakpoint added', breakpoint);
        });
    }
    /**
     * Remove a breakpoint
     *
     * @param breakpoint The breakpoint to remove
     */
    removeBreakpoint(breakpoint) {
        this._list = this._list.filter(bp => bp.breakpointId !== breakpoint.breakpointId);
        this._debug.removeBreakpoint(breakpoint.breakpointId);
        this._pending = this._pending.filter(bp => breakpoint.breakpoint.getBreakpointId() !== bp.getBreakpointId());
        Logger_1.default.breakpoint('breakpoint removed ', breakpoint.breakpoint);
    }
    /**
     * Handle a breakpoint being fired
     *
     * @param message The information about the current state of the application
     */
    breakpointFired(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const timestamp = new Date().valueOf();
            const breakpoint = this.find(message.params.hitBreakpoints[0]);
            if (!breakpoint) {
                Logger_1.default.error('hit breakpoint not found', message.params.hitBreakpoints[0]);
                this.session.post('Debugger.resume');
                return;
            }
            Logger_1.default.breakpoint('breakpoint hit', breakpoint.breakpoint);
            this.checkFireCount(breakpoint);
            try {
                const timer = new Timer_1.default();
                timer.start();
                const namedWatchersMap = breakpoint.breakpoint.getNamedWatchersMap();
                const snapshotInfo = this.generateSnapshot(message.params.callFrames, namedWatchersMap);
                Logger_1.default.info(`data gathered, resuming (paused for ${timer.diff()})`);
                this.session.post('Debugger.resume');
                yield Promise.all(snapshotInfo.rawSnapshot.map((snapshot) => this.resolveMappings(snapshot, breakpoint)));
                const snapshot = new Snapshot_1.default(timestamp, snapshotInfo.rawSnapshot);
                snapshot.breakpoint = breakpoint.breakpoint;
                snapshot.named_watches = snapshotInfo.named_watches;
                this._events.push(snapshot);
            }
            catch (e) {
                this.session.post('Debugger.resume');
                Logger_1.default.error('Failed to generate snapshot', e);
            }
        });
    }
    /**
     * Update the fire count of a breakpoint
     *
     * @param breakpoint The breakpoint to check
     */
    checkFireCount(breakpoint) {
        const fireCount = breakpoint.breakpoint.getFireCount() - 1;
        breakpoint.breakpoint.setFireCount(fireCount);
        if (fireCount <= 0) {
            this.removeBreakpoint(breakpoint);
        }
    }
    /**
     * Generate a snapshot based on the given call frames
     *
     * @param callFrames The call frames
     * @param namedWatchersMap Any named watchers that need processing
     */
    generateSnapshot(callFrames, namedWatchersMap) {
        const providers = [
            { token: inspector_1.default.Session, use: this.session },
        ];
        /**
         * This has to be done here as RuntimeProps has to be initialized for each snapshot,
         * so each snapshot is different
         */
        const runtimeProps = Container_1.default.bootstrap(RuntimeProps_1.default, providers);
        const frames = callFrames
            .filter(cf => {
            if (!cf.url.startsWith(Configuration_1.default.root)) {
                return false;
            }
            return !cf.url.substr(Configuration_1.default.root.length)
                .startsWith('/node_modules/');
        }) // only get frames in their code
            .reduce((prev, curr) => [...prev, ...curr.scopeChain.map(scope => ({ scope, frame: curr }))], []) // merge the frames together
            .filter(item => !['global'].includes(item.scope.type)) // remove global scope
            .map(({ frame, scope }) => ({
            file: frame.url.substr(Configuration_1.default.root.length),
            frameId: frame.callFrameId,
            line: scope.startLocation ? scope.startLocation.lineNumber + 1 : -1,
            method: scope.name || frame.url.split('/').pop(),
            class: scope.type,
            variables: runtimeProps.getFullProp(scope, 1).children,
        }));
        const named_watches = this._debug.addWatchers(namedWatchersMap, frames[0].frameId, runtimeProps);
        return {
            rawSnapshot: frames,
            named_watches
        };
    }
    /**
     * Convert the raw file paths and numbers back into the source files where possible
     *
     * @param snapshot The raw snapshot
     * @param breakpoint The full breakpoint
     */
    resolveMappings(snapshot, breakpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mappings.reverseHas(snapshot.file)) {
                return;
            }
            const map = this._mappings.reverseGet(snapshot.file);
            const methodIsFile = snapshot.method.split('.').pop() === snapshot.file.split('.').pop();
            const rootFilePath = Configuration_1.default.rootPath;
            const relativeMappedPath = map.sourcesResolved[0].substr(rootFilePath.length);
            if (methodIsFile) {
                // replace the .js with the mapped file
                snapshot.method = map.sourcesResolved[0].split('/').pop();
            }
            snapshot.file = relativeMappedPath;
            map.sourceRoot = rootFilePath + '/';
            map.file = map.originalFilePath.substr(Configuration_1.default.root.length);
            map.sources = [relativeMappedPath];
            yield source_map_1.SourceMapConsumer.with(map, null, (consumer) => __awaiter(this, void 0, void 0, function* () {
                const originalPosition = {
                    line: snapshot.line,
                    column: breakpoint.column
                };
                ({ line: snapshot.line } = consumer.originalPositionFor(originalPosition));
            }));
        });
    }
    /**
     * When a source map is parsed, see if any pending breakpoints are applicable, and set them
     *
     * @param path The file path that was parsed
     * @param map The source map
     */
    mappingParsed(path, map) {
        return __awaiter(this, void 0, void 0, function* () {
            const breakpoints = [];
            this._pending = this._pending.filter((bp => {
                const matchesPath = Configuration_1.default.rootPath + bp.getRelPath() === path;
                if (matchesPath) {
                    breakpoints.push(bp);
                }
                return !matchesPath;
            }));
            if (!breakpoints.length) {
                return;
            }
            const source = Configuration_1.default.rootPath + breakpoints[0].getRelPath();
            map.sourceRoot = Configuration_1.default.rootPath + '/';
            map.file = map.originalFilePath.substr(Configuration_1.default.root.length);
            map.sources = [breakpoints[0].getRelPath()];
            yield source_map_1.SourceMapConsumer.with(map, null, (consumer) => __awaiter(this, void 0, void 0, function* () {
                breakpoints.forEach(breakpoint => {
                    let line = breakpoint.getLineNo();
                    let column = 0;
                    ({ line, column } = consumer.generatedPositionFor({ line, source, column }));
                    line -= 1; // source map line numbers start at 1, js starts at 0
                    const breakpointId = this._debug.addBreakpoint(breakpoint, {
                        url: Configuration_1.default.root + map.file,
                        lineNumber: line,
                        columnNumber: column,
                    }, this.breakpointFired.bind(this));
                    this._list.push({ breakpoint, breakpointId, column });
                    Logger_1.default.breakpoint('breakpoint added', breakpoint);
                });
            }));
        });
    }
};
Breakpoints = __decorate([
    Injectable_1.default(),
    __metadata("design:paramtypes", [Debug_1.Debug,
        Events_1.default,
        Mappings_1.default, inspector_1.default.Session])
], Breakpoints);
exports.default = Breakpoints;
