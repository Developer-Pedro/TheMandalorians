"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Injectable_1 = __importDefault(require("../decorators/Injectable"));
const source_map_resolve_1 = require("source-map-resolve");
const fs_1 = require("fs");
const Configuration_1 = __importDefault(require("../models/Configuration"));
const util_1 = require("util");
const readFilePromise = util_1.promisify(fs_1.readFile);
const resolvePromise = util_1.promisify(source_map_resolve_1.resolve);
let Mappings = class Mappings {
    constructor() {
        this._seen = [];
        this._mapping = new Map();
        this._reverseMap = new Map();
    }
    /**
     * Set a handler to be used when a file mapping is parsed
     *
     * @param handler The handler
     */
    set mappingParsed(handler) {
        this._mappingParsed = handler;
    }
    /**
     * Process a file that was just loaded by node to see if it has source maps
     *
     * @param message The file that was loaded
     */
    process(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = message.params.url.substring(7);
            const source = yield readFilePromise(filePath);
            const result = yield resolvePromise(source.toString(), filePath, fs_1.readFile);
            if (!result) {
                // this file has no sourcemap, it's probably just a normal js file
                this._seen.push(filePath);
                return;
            }
            result.map.sourcesContent = result.sourcesContent;
            result.map.sourcesResolved = result.sourcesResolved;
            result.map.originalFilePath = message.params.url;
            this._mapping.set(result.sourcesResolved[0], result.map);
            this._reverseMap.set(message.params.url.substring(Configuration_1.default.root.length), result.sourcesResolved[0]);
            this._seen.push(filePath);
            this._mappingParsed(result.sourcesResolved[0], result.map);
        });
    }
    has(key) {
        return this._mapping.has(key);
    }
    get(key) {
        return this._mapping.get(key);
    }
    reverseHas(key) {
        return this._reverseMap.has(key);
    }
    reverseGet(key) {
        return this.get(this._reverseMap.get(key));
    }
    seen(key) {
        return this._seen.includes(key);
    }
};
Mappings = __decorate([
    Injectable_1.default()
], Mappings);
exports.default = Mappings;
