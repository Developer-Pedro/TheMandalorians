"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Inject_1 = require("../decorators/Inject");
class Container {
    constructor() {
        /**
         * A list of already instantiated classes, currently all classes are singletons
         */
        this.instances = {};
        /**
         * Any providers that have been explicitly defined
         */
        this.providers = [];
    }
    /**
     * Instantiate an @Injectable() class and return it
     *
     * @param target The class to instantiate
     * @param providers A list of providers, these take priority over automatic injection
     */
    static bootstrap(target, providers = []) {
        return (new this())
            .addProviders(providers)
            .resolve(target);
    }
    ;
    /**
     * Add providers
     *
     * @param providers
     */
    addProviders(providers) {
        this.providers = this.providers.concat(providers);
        return this;
    }
    /**
     * Instantiate the requested class and its' dependencies
     *
     * @param requested The class to instantiate
     * @param injectChain The parent chain of parents that requested this class
     */
    resolve(requested, injectChain = []) {
        if (!requested) {
            throw new Error(`Cannot resolve circular dependency: ${injectChain.join(' -> ')}(constructor)`);
        }
        if (this.instances[requested.name]) {
            return this.instances[requested.name];
        }
        injectChain = [...injectChain, requested.name];
        // get the dependencies for the requested class
        const tokens = Reflect.getMetadata('design:paramtypes', requested) || [];
        // instantiate each of those dependencies
        const injections = tokens.map((token, index) => {
            const overrideToken = Inject_1.getOverrideInjection(requested, index);
            // TODO: what if we want to override one of the existing classes?
            if (overrideToken) {
                const provider = this.getProvider(overrideToken);
                return provider.use;
            }
            const provider = this.providers.find(p => p.token.name === token.name);
            return provider ? provider.use : this.resolve(token, injectChain);
        });
        // instantiate the class with the found dependencies and remember it
        return this.instances[requested.name] = new requested(...injections);
    }
    /**
     * Get a provider from an InjectToken
     *
     * @param token
     */
    getProvider(token) {
        const provider = this.providers.find(p => p.token.identifier === token.identifier);
        if (!provider) {
            throw new Error(`No provider for InjectToken '${token.identifier}'`);
        }
        return provider;
    }
}
exports.default = Container;
