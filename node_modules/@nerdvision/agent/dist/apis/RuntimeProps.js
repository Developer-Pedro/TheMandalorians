"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inspector_1 = require("inspector");
const Injectable_1 = __importDefault(require("../decorators/Injectable"));
const NerdVisionAgent_1 = require("../NerdVisionAgent");
const quicksort_1 = require("../utils/functions/quicksort");
let RuntimeProps = class RuntimeProps {
    constructor(_session) {
        this._session = _session;
        this._currentId = 0;
        this._seenHashes = new Map();
        this._maxDepth = 5;
    }
    /**
     * Allowing this to be set, for testing purposes
     *
     * @param maxDepth
     */
    set maxDepth(maxDepth) {
        this._maxDepth = maxDepth;
    }
    get seenHashes() {
        return this._seenHashes;
    }
    getNextId() {
        return ++this._currentId;
    }
    /**
     * Get the given prop from Runtime or from the cache
     *
     * @param rawProperty
     * @param depth
     */
    getFullProp(rawProperty, depth) {
        // the objectId could be anywhere
        const sub = rawProperty.value || rawProperty.symbol || rawProperty.object || {};
        // we don't use everything in rawProperty, so we'll return property which only contains what we need
        const property = {
            name: rawProperty.name,
            type: sub.className || sub.subtype || sub.type,
            value: sub.value,
        };
        // primitive values have no objectId, so we can just return them
        if (!Object.keys(sub).length || !sub.objectId || depth > this._maxDepth) {
            return Object.assign(property, { id: this.getNextId() });
        }
        const rawChildren = this.getChildrenFromRuntime(sub.objectId);
        const hash = this.generateHash(sub, rawChildren);
        // if we've seen this has before, we'll just return a reference to that
        if (this._seenHashes.has(hash)) {
            return {
                id: this._seenHashes.get(hash),
                name: rawProperty.name,
            };
        }
        // this must be a new property, let's give it an id
        property.id = this.getNextId();
        this._seenHashes.set(hash, property.id);
        property.children = [];
        // nextDepth should always be the same at this stage
        const nextDepth = depth + 1;
        // get the properties for all its children
        for (let i = 0; i < rawChildren.length; i++) {
            if (!rawChildren[i].value || rawChildren[i].value.className !== NerdVisionAgent_1.NerdVisionAgent.name) {
                property.children.push(this.getFullProp(rawChildren[i], nextDepth));
            }
        }
        return property;
    }
    /**
     * Generate a hash so we can check if we've already seen a variable with the same type & immediate children
     *
     * @param sub
     * @param result
     */
    generateHash(sub, result) {
        // we start by generating a string version of the property types
        let hash = this.objToString(sub, { objectId: undefined });
        const unsortedHashable = [];
        // then we add in the children, but removing the objectId
        for (let i = 0; i < result.length; i++) {
            const details = result[i].value || result[i].symbol || {};
            // objToString isn't recursive, so we process result and details separately
            unsortedHashable[i] = this.objToString(result[i], { value: undefined, symbol: undefined })
                + this.objToString(details, { objectId: undefined });
        }
        // we sort then reduce to ensure that the children are always in the same order
        hash += quicksort_1.quickSort(unsortedHashable)
            .reduce((prev, curr) => prev + curr, '');
        return hash;
    }
    /**
     * Get the children from the Runtime
     *
     * @param objectId
     */
    getChildrenFromRuntime(objectId) {
        let props = { internalProperties: [], result: [] };
        let error;
        // get the immediate children from Runtime, this call is synchronous
        this._session.post('Runtime.getProperties', {
            objectId,
            ownProperties: true
        }, (err, resp) => {
            if (err) {
                error = err;
                return;
            }
            if (resp) {
                props = resp;
            }
        });
        const result = [];
        for (let i = 0; i < props.result.length; i++) {
            if (props.result[i].name !== '__proto__') {
                result.push(props.result[i]);
            }
        }
        return result;
    }
    /**
     * Convert an object to a string
     *
     * @param objs
     */
    objToString(...objs) {
        const obj = Object.assign({}, ...objs);
        const sorted = quicksort_1.quickSort(Object.keys(obj));
        let str = '';
        for (let i = 0; i < sorted.length; i++) {
            str += sorted[i] + obj[sorted[i]];
        }
        return str;
    }
};
RuntimeProps = __decorate([
    Injectable_1.default(),
    __metadata("design:paramtypes", [inspector_1.Session])
], RuntimeProps);
exports.default = RuntimeProps;
