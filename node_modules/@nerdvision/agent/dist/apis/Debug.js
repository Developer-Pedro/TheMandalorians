"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inspector_1 = __importDefault(require("inspector"));
const Logger_1 = __importDefault(require("../utils/Logger"));
const Configuration_1 = __importDefault(require("../models/Configuration"));
const Injectable_1 = __importDefault(require("../decorators/Injectable"));
const Mappings_1 = __importDefault(require("../utils/Mappings"));
let Debug = class Debug {
    constructor(_mapping, session) {
        this._mapping = _mapping;
        this.session = session;
        this._handlers = {};
    }
    /**
     * Connect to the node debugger
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.session.connect();
            this.session.on('Debugger.scriptParsed', this.debuggerScriptParsed.bind(this));
            this.session.on('Debugger.paused', this.debuggerPaused.bind(this));
            this.session.post('Debugger.enable');
            this.session.post('Debugger.setBreakpointsActive', { active: true });
        });
    }
    /**
     * Set a breakpoint on the node debugger
     *
     * @param breakpoint The breakpoint to set
     * @param params The breakpoint parameters
     * @param handler The handler for when the breakpoint fires
     */
    addBreakpoint(breakpoint, params, handler) {
        if (breakpoint.getCondition()) {
            params.condition = breakpoint.getCondition();
        }
        let breakpointId;
        this.session.post('Debugger.setBreakpointByUrl', params, (error, response) => {
            if (error) {
                Logger_1.default.breakpoint(`couldn't set breakpoint: ${error.message}`, breakpoint);
                return;
            }
            this._handlers[response.breakpointId] = handler;
            breakpointId = response.breakpointId;
        });
        return breakpointId;
    }
    /**
     * Remove a breakpoint from the node debugger
     *
     * @param breakpointId The breakpoint id from node
     */
    removeBreakpoint(breakpointId) {
        this.session.post('Debugger.removeBreakpoint', { breakpointId }, (error) => {
            if (error) {
                Logger_1.default.error(`couldn't remove breakpoint: ${error.message} ${breakpointId}`);
                return;
            }
            delete this._handlers[breakpointId];
        });
    }
    /**
     * Evaluate a set of watchers on the given call frame
     *
     * @param namedWatchers The watchers
     * @param callFrameId The cool frame id
     * @param runtimeProps The variable reference
     */
    addWatchers(namedWatchers, callFrameId, runtimeProps) {
        const watches = namedWatchers.getEntryList().map((watcher) => {
            const evaluated = this.evaluateNamedWatcher(watcher[1], callFrameId);
            // if this is null - couldn't evaluate this expression
            if (!evaluated || evaluated.exceptionDetails) {
                return {
                    expression: watcher[1],
                    name: watcher[0],
                    variables: [{
                            value: "undefined"
                        }]
                };
            }
            // expression was evaluated and given a value
            if (evaluated.result.type !== 'object') {
                return {
                    expression: watcher[1],
                    name: watcher[0],
                    variables: [{
                            id: runtimeProps.getNextId(),
                            name: watcher[0],
                            type: evaluated.result.type,
                            value: evaluated.result.value
                        }]
                };
            }
            // reference to a variable already found
            const children = runtimeProps.getChildrenFromRuntime(evaluated.result.objectId);
            const hash = runtimeProps.generateHash(evaluated.result, children);
            const variableId = runtimeProps.seenHashes.get(hash);
            // adding the reference to the variable that this points to
            if (variableId) {
                return {
                    expression: watcher[1],
                    name: watcher[0],
                    variables: [{
                            id: variableId,
                            name: watcher[0]
                        }]
                };
            }
            const variables = [];
            // if it couldn't find id, get full properties for each child
            children.forEach(child => {
                variables.push(runtimeProps.getFullProp(child, 1));
            });
            return {
                expression: watcher[1],
                name: watcher[0],
                variables
            };
        });
        return watches;
    }
    /**
     * Get the value of the named watcher
     *
     * @param expression The expression to evaluate
     * @param callFrameId The call frame to evaluate it on
     */
    evaluateNamedWatcher(expression, callFrameId) {
        let result = null;
        this.session.post('Debugger.evaluateOnCallFrame', {
            expression,
            callFrameId
        }, (err, resp) => {
            if (err) {
                Logger_1.default.error(err);
                return;
            }
            result = resp;
        });
        return result;
    }
    /**
     * Handle the debugger pausing
     *
     * @param message The information at the time of pausing
     */
    debuggerPaused(message) {
        if (!message.params.hitBreakpoints[0]) {
            return;
        }
        if (!this._handlers[message.params.hitBreakpoints[0]]) {
            Logger_1.default.log('breakpoint hit but no handler was found, resuming', message.params.hitBreakpoints[0]);
            this.session.post('Debugger.resume');
            return;
        }
        this._handlers[message.params.hitBreakpoints[0]](message);
    }
    /**
     * Handle a script being parsed by node
     *
     * @param message Information about the parsed file
     */
    debuggerScriptParsed(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message.params.url.startsWith(Configuration_1.default.root) && !message.params.url.includes('/node_modules/')) {
                yield this._mapping.process(message);
            }
        });
    }
};
Debug = __decorate([
    Injectable_1.default(),
    __metadata("design:paramtypes", [Mappings_1.default, inspector_1.default.Session])
], Debug);
exports.Debug = Debug;
